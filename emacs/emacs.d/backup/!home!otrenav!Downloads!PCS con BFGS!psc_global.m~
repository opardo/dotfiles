%
% Solucion al problema cuadratico con restricciones
% utilizando programacion cuadratica sucesiva.
%
% Prof. Zeferino Parada
% Optimizacion Numerica
% Omar Trejo Navarro, 119711
% Juan Pedro Luengas Garcia, 119493
% Natalia Orozco Urquijo, 111008
% ITAM, 2015
%
function [x, fval, iter, lambda, fin] = psc_global(fname, funh, x, maxiter)
    tol = .01;
    c = 1.0;   % Penalizacion
    iter = 0;
    f = feval(fname, x);
    h = feval(funh, x);
    df = gradiente(fname, x);
    dh = jacobiana(funh, x);
    n = length(x);
    m = length(h);
    B  = eye(n,n);
    lambda = ones(m,1);
    fin = norm([[df + dh'*lambda]' h']);

    while ((fin >= tol) && (iter < maxiter))
        lastLag = (df + dh'*lambda);
        [p, lambda] = pc_directo(B, dh, df, -h);
        normah = norm(h);
        if (normah > 1e-6)
            gradl = df + dh'*lambda;
            sigma = (gradl'*p)/(h'*h);
            CAux = abs(sigma) + 1;
            c = max([c CAux]);

            % Busqueda de linea
            % Condiciones de Wolf
            cond1 = f + h'*lambda + (c/2)*h'*h;
            cond2 = (df + dh'*lambda)'*p - c*h'*h;
            alfa = 1.0;
            xt = x + alfa*p;
            fxt = feval(fname, xt);
            hxt = feval(funh, xt);
            Lxt = fxt + hxt'*lambda + (c/2)*(hxt'*hxt);
            c1 = 1e-4;
            j = 0;
            jmax = 13;
            while(Lxt > cond1 + alfa*c1*cond2 && j < jmax)
                alfa = alfa/2;
                xt = x + alfa*p;
                fxt = feval(fname,xt);
                hxt = feval(funh,xt);
                Lxt = fxt + hxt'*lambda + (c/2)*(hxt'*hxt);
                j = j + 1;
            end
            if j == jmax
                alfa = 1;
            end
        else
            alfa = 1;
        end

        % Actualizamos
        x = x + alfa*p;
        f = feval(fname, x);
        h = feval(funh, x);
        df = gradiente(fname, x);
        dh = jacobiana(funh, x);

        % Multiplicador por
        % minimos cuadrados lineales
        lambda = -(dh*dh')\(dh*df);
        lag = df + dh'*lambda ;

        % Actualizacion BFGS (Powell)
        B = bfgs_powell(B, alfa*p, lag - lastLag);
        fin = norm([(df + dh'*lambda)' h']);
        iter = iter + 1;
        if n >= 120
            normrec(iter) = fin;
        end
    end

    % Grafica (norm(lagrangeano) vs #(iteraciones))
    if n >= 120
        plot(1:iter, normrec)
    end
    fval = feval(fname, x);
end
